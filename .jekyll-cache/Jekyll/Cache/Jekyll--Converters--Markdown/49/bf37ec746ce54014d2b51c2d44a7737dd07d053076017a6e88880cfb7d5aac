I"Mà<p>I‚Äôve spent the last couple years learning JavaScript, but I‚Äôm just now starting to get the hang of closure. It‚Äôs a tricky but important concept, one that trips up a lot of programmers new to JavaScript and sometimes even eludes experienced developers.</p>

<p>In this post, I‚Äôm going to try and explain the concept to the best of my abilities. This will by no means be a comprehensive explanation, and given my limited expertise I encourage readers to check out more authoritative sources before carrying whatever knowledge gained here into practice.</p>

<p>In particular, I highly recommend reading Kyle Simpson‚Äôs <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch5.md">chapter on closure</a> from his excellent <a href="https://github.com/getify/You-Dont-Know-JS">You Don‚Äôt Know JS</a> series and the relevant passages from Douglas Crockford‚Äôs classic, <a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742">JavaScript: The Good Parts</a>.</p>

<h2 id="lets-talk-about-scope">Let‚Äôs talk about scope</h2>

<p>Before getting to closure, it‚Äôs important to understand what scope is and how it works.</p>

<p><strong>Put simply, in JavaScript scope refers to the rules that the engine abides by when it performs variable lookups.</strong> As you probably know, successfully looking up variables depends a lot on the namespaces they were assigned to and the context from which they are being looked up.</p>

<p>Most developers know that trying to reference variables that were defined within a function from beyond the context of that function will return an error. This is because the variables were scoped to the namespace of the function they were defined in, and trying to call these variables from outside that namespace is forbidden by JavaScript‚Äôs engine.</p>

<p>Take a look at the following code snippet:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">I'm scoped to global!</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">I'm scoped to foo!</span><span class="dl">"</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">();</span> <span class="c1">// I'm scoped to global! I'm scoped to foo!</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// error</span></code></pre></figure>

<p>When we invoke <code class="highlighter-rouge">foo</code>, the engine steps inside the function to execute its code, so to speak. This means that while its executing <code class="highlighter-rouge">foo</code>, the engine has access to all the variables mapped to that function‚Äôs namespace. For these reasons, <code class="highlighter-rouge">foo</code> is able to log successfully both <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code>.</p>

<p>We run into problems when we attempt to log <code class="highlighter-rouge">b</code> from outside of <code class="highlighter-rouge">foo</code>. While it may seem strange that that the engine raises an error when we try to call <code class="highlighter-rouge">b</code> just six lines after defining it, according to the rules of scope, <code class="highlighter-rouge">b</code> is mapped to <code class="highlighter-rouge">foo</code>‚Äôs namespace. Trying to access <code class="highlighter-rouge">b</code> from outside the context of <code class="highlighter-rouge">foo</code>‚Äôs namespace is just not possible.</p>

<p>That being understood, why then was <code class="highlighter-rouge">foo</code> able to call <code class="highlighter-rouge">a</code>? It seem‚Äôs like a contradiction to say that on one hand we are unable to look up <code class="highlighter-rouge">b</code> from outside <code class="highlighter-rouge">foo</code> because <code class="highlighter-rouge">foo</code> is where <code class="highlighter-rouge">b</code> was created, but on the other hand to say that <code class="highlighter-rouge">foo</code> can totally look up <code class="highlighter-rouge">a</code> even though <code class="highlighter-rouge">a</code> wasn‚Äôt defined there. Both lookups refer to variables that were defined somewhere other than the execution context of the call, so why does JavaScript forbid one lookup but not the other?</p>

<p>The answer has less to do with what kind of lookups are forbidden and allowed by the JavaScript engine, and more with how that actual lookup process is performed. <strong>At this point, I should come clean about something: when I say scope is all about rules, I‚Äôm being a little misleading. In truth, it‚Äôs more appropriate to think of scope in terms of a constrained route the engine takes when it‚Äôs tasked with looking up variables.</strong></p>

<p>When you reference a variable in your code, the JavaScript engine takes a strongly specified path to look it up. First, it looks to see if the variable was added to the current scope, that is, it checks to see if that variable exists within the namespace of the current execution context (ie, function). If it doesn‚Äôt find the variable in the current namespace, it take one step backward and checks to see if the namespace of the parent scope contains the requested variable. If again the engine fails to find the variable there, it checks the namespace of the parent‚Äôs parent scope, and so on all the way to the <code class="highlighter-rouge">global</code> scope.</p>

<p>The <code class="highlighter-rouge">global</code> scope happens to be the final namespace on the engine‚Äôs lookup path. It provides access to variables that were defined outside of any function or variables that were declared without the preceding keyword <code class="highlighter-rouge">var</code>. There is no parent scope to <code class="highlighter-rouge">global</code>, so if the engine reaches it all the way here without finding the variable it needs, it raises a reference error.</p>

<p>All functions and their namespaces, no matter how deeply nested, have access to the variables scoped to <code class="highlighter-rouge">global</code>. As a result, it can be very tempting to define all of the variables you‚Äôll ever need in the namespace of the <code class="highlighter-rouge">global</code> scope. <strong>In truth, however, assigning variables to <code class="highlighter-rouge">global</code> is rarely a good idea, and it should be avoided.</strong></p>

<p>Now that we know a little more about scope, the answer to our question about why <code class="highlighter-rouge">foo</code> was able to reference <code class="highlighter-rouge">a</code> should be clear. Here‚Äôs the code snippet from earlier:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">I'm scoped to global!</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">I'm scoped to foo!</span><span class="dl">"</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">();</span> <span class="c1">// I'm scoped to global! I'm scoped to foo!</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// error</span></code></pre></figure>

<p><code class="highlighter-rouge">a</code> was defined within the <code class="highlighter-rouge">global</code> scope. When we invoke <code class="highlighter-rouge">foo</code>, the engine is tasked with finding <code class="highlighter-rouge">a</code>. When it fails to find it within <code class="highlighter-rouge">foo</code>‚Äôs namespace, the engine takes a step backward and finds it in <code class="highlighter-rouge">foo</code>‚Äôs parent, the <code class="highlighter-rouge">global</code> scope.</p>

<p>Knowing how variables are looked up by the engine is important, and it allows us to better appreciate what the engine is doing to find variables. Before moving on to closure, however, I think it would serve our purpose to examine one more code snippet:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">I'm scoped to foo!</span><span class="dl">"</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">I'm scoped to bar!</span><span class="dl">"</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">bar</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">baz</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">I'm scoped to baz!</span><span class="dl">"</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">();</span> <span class="c1">// I'm scoped to foo! I'm scoped to bar!</span>
<span class="nx">baz</span><span class="p">();</span> <span class="c1">// error</span></code></pre></figure>

<p>Before you continue reading, try and figure out why invoking <code class="highlighter-rouge">foo</code> succeeded and invoking <code class="highlighter-rouge">baz</code> failed. What path does the engine take to look up the variables these two functions reference?</p>

<p>As I mentioned earlier, it‚Äôs only somewhat correct to say that the reason invoking <code class="highlighter-rouge">baz</code> raises an error when it attempts to log <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> is because the rules of scope forbid the engine from breaking the current execution context (which happens to be the function <code class="highlighter-rouge">baz</code>) and accessing the namespaces of <code class="highlighter-rouge">foo</code> and <code class="highlighter-rouge">bar</code>, the functions where those variables are defined. It‚Äôs better to say that the reason has to do with the route the engine takes when it tries to find those variables, a route that <code class="highlighter-rouge">foo</code> and <code class="highlighter-rouge">bar</code> just aren‚Äôt on.</p>

<p>Following the variable lookup path helps reveal why <code class="highlighter-rouge">baz</code> came up short when it tried calling <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code>. Tracing the lookup path taken by the engine when we invoke <code class="highlighter-rouge">foo</code> also explains why that function was able to successfully look up the same variables.</p>

<p>The final line of <code class="highlighter-rouge">foo</code> invokes <code class="highlighter-rouge">bar</code>, a function nested inside <code class="highlighter-rouge">foo</code> that logs the two variables. This means that invoking <code class="highlighter-rouge">foo</code> pushes our execution context to <code class="highlighter-rouge">bar</code>. Finding <code class="highlighter-rouge">b</code> from inside <code class="highlighter-rouge">bar</code> is easy for the JavaScript engine since that‚Äôs the function where <code class="highlighter-rouge">b</code> was declared. The process the engine takes to find <code class="highlighter-rouge">a</code>, however, is complicated by the fact that there is no variable named <code class="highlighter-rouge">a</code> in <code class="highlighter-rouge">bar</code>‚Äôs namespace. Upon finding this out, the engine consults the namespace of <code class="highlighter-rouge">bar</code>‚Äôs parent scope, <code class="highlighter-rouge">foo</code>, where there is a variable named <code class="highlighter-rouge">a</code>. Hence, both variables are successfully able to be looked up by the engine and logged to the console.</p>

<p>We started this discussion by thinking about scope in terms of rules of access the engine follows when it performs variable lookups. We ended it, however, by demonstrating a subtle but important reformulation: <strong>scope is the constraining mechanism that binds the engine to a specified path of nested namespaces in order to complete variable lookups.</strong> Starting with the scope of the current execution context, upon failing to find a variable the engine navigates backward consulting each parent scope until reaching the <code class="highlighter-rouge">global</code> scope, ultimately either finding the variable it needs and returning its value or not and raising a reference error.</p>

<h2 id="on-to-closure">On to closure‚Ä¶</h2>

<p>Let‚Äôs take a look at another code snippet:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">I'm scoped to bar!</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span>  <span class="p">{</span>
    <span class="na">bar</span><span class="p">:</span> <span class="nx">bar</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">bar</span><span class="p">();</span> <span class="c1">// error</span>

<span class="kd">var</span> <span class="nx">baz</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">();</span>
<span class="nx">baz</span><span class="p">.</span><span class="nx">bar</span><span class="p">();</span> <span class="c1">// I'm scoped to bar!</span></code></pre></figure>

<p>Here we‚Äôve created a function that returns an object. The object contains only one property, a method named <code class="highlighter-rouge">bar</code> that happens to point to a function of the same name nested inside <code class="highlighter-rouge">foo</code>. Trying to call <code class="highlighter-rouge">bar()</code> from the execution context of the <code class="highlighter-rouge">global</code> scope results in an error.</p>

<p>So far, none of this is surprising. When we try to invoke <code class="highlighter-rouge">bar</code> from the <code class="highlighter-rouge">global</code> scope, we are essentially trying to call a function that cannot be accessed by the engine. <code class="highlighter-rouge">bar</code> is scoped to <code class="highlighter-rouge">foo</code>, so trying to call <code class="highlighter-rouge">bar</code> from the context of the <code class="highlighter-rouge">global</code> scope, which is the parent of <code class="highlighter-rouge">foo</code>, will fail. <strong>Remember, when the engine can‚Äôt find something in the namespace of the current execution context, it starts looking in the namespace of each parent scope.</strong> The <code class="highlighter-rouge">global</code> scope doesn‚Äôt have any parents, so when the engine fails to find <code class="highlighter-rouge">bar</code> in the <code class="highlighter-rouge">global</code> namespace, it‚Äôs forced to return an error.</p>

<p>Notice, however, that invoking <code class="highlighter-rouge">baz.bar</code> executes correctly. Given our knowledge of scope, this should raise an important question: why is it that calling a method from the <code class="highlighter-rouge">global</code> scope that happens to point to <code class="highlighter-rouge">bar</code> succeeds and just calling <code class="highlighter-rouge">bar</code> directly fails? Aren‚Äôt both of these invocations performing lookups on a function that is defined in a namespace that cannot be reached from <code class="highlighter-rouge">global</code>?</p>

<p><strong>The reason this works is because <code class="highlighter-rouge">baz.bar</code>, being a property on the object returned by <code class="highlighter-rouge">foo</code>, has closure over <code class="highlighter-rouge">foo</code>.</strong> The upshot of this is that when <code class="highlighter-rouge">baz.bar</code> gets invoked, the execution context slides momentarily back inside <code class="highlighter-rouge">bar</code>, meaning that <code class="highlighter-rouge">baz.bar</code> can call any variables that <code class="highlighter-rouge">bar</code> had access to as a function nested inside <code class="highlighter-rouge">foo</code>.</p>

<p>This might give you the impression that <code class="highlighter-rouge">baz.bar</code> is breaking the ‚Äúrules‚Äù of scope by being able to reference variables that aren‚Äôt within the current execution context of <code class="highlighter-rouge">baz</code> (ie, the <code class="highlighter-rouge">global</code> scope). <strong>In truth, calling <code class="highlighter-rouge">baz.bar</code> shifts the execution context, so to speak, so no ‚Äúrules‚Äù are being broken here, and lookups get performed just as would be expected.</strong></p>

<p>If you think this has something to do with the fact that <code class="highlighter-rouge">baz.bar</code> is a method on the object returned by <code class="highlighter-rouge">foo</code>, think again. The following code operates according to the same logic of closure:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>

  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">I've been scoped to foo!</span><span class="dl">"</span>

  <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">bar</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>  <span class="c1">// error</span>
<span class="nx">bar</span><span class="p">();</span>           <span class="c1">// error</span>

<span class="kd">var</span> <span class="nx">baz</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">();</span> <span class="c1">// returns a pointer to the function object bar and assigns it to baz</span>
<span class="nx">baz</span><span class="p">();</span>           <span class="c1">// I've been scoped to foo!</span></code></pre></figure>

<p><code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">bar</code> are both scoped to <code class="highlighter-rouge">foo</code>‚Äôs namespace, so attempting to call them from the <code class="highlighter-rouge">global</code> scope results in an error. <code class="highlighter-rouge">baz</code>, on the other hand, is assigned to the result of invoking <code class="highlighter-rouge">foo</code>, meaning that <code class="highlighter-rouge">baz</code> points to <code class="highlighter-rouge">bar</code>. Just like in our earlier example when I said that <code class="highlighter-rouge">baz.bar</code> had closure over <code class="highlighter-rouge">foo</code>, here <code class="highlighter-rouge">bar</code> also has closure over <code class="highlighter-rouge">foo</code>. This means that invoking <code class="highlighter-rouge">baz</code> in turn invokes <code class="highlighter-rouge">bar</code>, and this, speaking a little crudely, <strong>is what slides the execution context back inside <code class="highlighter-rouge">bar</code>, a subtle maneuver affording the engine a variable lookup path on which it can locate <code class="highlighter-rouge">a</code>.</strong></p>

<p>In both these examples, <code class="highlighter-rouge">bar</code> has closure over <code class="highlighter-rouge">foo</code>, the function it was created in. And since <code class="highlighter-rouge">foo</code> returned <code class="highlighter-rouge">bar</code>‚Äîas either a method on an object or directly itself‚Äîin a certain fashion <code class="highlighter-rouge">bar</code> can continue to live on and function even outside <code class="highlighter-rouge">foo</code>‚Äôs scope.</p>

<h2 id="privacy">Privacy</h2>

<p>If you understand closure and it doesn‚Äôt seem surprising to you, congratulations, you must have an excellent understanding of scope. Being able to intuitively determine how context shifts as code gets executed and how variables are looked up according to the scoping mechanism are the prerequisites to understanding and employing closure. <strong>When these things become second nature, so too will the idea of closure.</strong></p>

<p>With that said, it‚Äôs worthwhile to dwell on the powerful functionality that closure affords. <strong>Because closure allows us to reference variables scoped to namespaces we otherwise could not access, it‚Äôs very easy to write code whose execution relies on private resources.</strong></p>

<p>Consider the following code snippet:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">createProfile</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">yearOfBirth</span><span class="p">)</span> <span class="p">{</span>

  <span class="kd">function</span> <span class="nx">updateUsername</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">yearOfBirth</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">name</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">yearOfBirth</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">changeName</span><span class="p">(</span><span class="nx">newName</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">newName</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">username</span> <span class="o">=</span> <span class="nx">updateUsername</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">yearOfBirth</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">changeYearOfBirth</span><span class="p">(</span><span class="nx">newYearOfBirth</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">yearOfBirth</span> <span class="o">=</span> <span class="nx">newYearOfBirth</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">username</span> <span class="o">=</span> <span class="nx">updateUsername</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">yearOfBirth</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">profile</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="nx">name</span><span class="p">,</span>
    <span class="na">yearOfBirth</span><span class="p">:</span> <span class="nx">yearOfBirth</span><span class="p">,</span>
    <span class="na">username</span><span class="p">:</span> <span class="nx">updateUsername</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">yearOfBirth</span><span class="p">),</span>
    <span class="na">changeName</span><span class="p">:</span> <span class="nx">changeName</span><span class="p">,</span>
    <span class="na">changeYearOfBirth</span><span class="p">:</span> <span class="nx">changeYearOfBirth</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="nx">profile</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">profile</span> <span class="o">=</span> <span class="nx">createProfile</span><span class="p">(</span><span class="dl">"</span><span class="s2">Franklin</span><span class="dl">"</span><span class="p">,</span> <span class="mi">1988</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">profile</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>        <span class="c1">// Franklin;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">profile</span><span class="p">.</span><span class="nx">yearOfBirth</span><span class="p">);</span> <span class="c1">// 1988</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">profile</span><span class="p">.</span><span class="nx">username</span><span class="p">);</span>    <span class="c1">// Frankl1988</span>

<span class="nx">profile</span><span class="p">.</span><span class="nx">username</span><span class="p">();</span>               <span class="c1">// error</span>

<span class="nx">profile</span><span class="p">.</span><span class="nx">changeName</span><span class="p">(</span><span class="dl">"</span><span class="s2">Montgomery</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">profile</span><span class="p">.</span><span class="nx">changeYearOfBirth</span><span class="p">(</span><span class="mi">1950</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">profile</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>        <span class="c1">// Montgomery</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">profile</span><span class="p">.</span><span class="nx">yearOfBirth</span><span class="p">);</span> <span class="c1">// 1950</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">profile</span><span class="p">.</span><span class="nx">username</span><span class="p">);</span>    <span class="c1">// Montgo1950</span></code></pre></figure>

<p>In this example, I have created a <code class="highlighter-rouge">createProfile</code> function that takes as arguments a name and a year of birth and returns a <code class="highlighter-rouge">profile</code> object. The <code class="highlighter-rouge">profile</code> object contains five properties, two of which are assigned to whatever name and year of birth that was originally passed to the <code class="highlighter-rouge">createProfile</code> function.</p>

<p>The property <code class="highlighter-rouge">username</code> is set to a string that is created as the result of passing <code class="highlighter-rouge">name</code> and <code class="highlighter-rouge">yearOfBirth</code> to the <code class="highlighter-rouge">updateUsername</code> function. <strong>Notice that <code class="highlighter-rouge">username</code> is not set to the function <code class="highlighter-rouge">updateUsername</code>; instead it‚Äôs set to the result of invoking <code class="highlighter-rouge">updateUsername</code>.</strong> If you tried to invoke <code class="highlighter-rouge">username</code> as a property of <code class="highlighter-rouge">profile</code> you would receive an error because <code class="highlighter-rouge">profile.username</code> is not a function. It‚Äôs just a string.</p>

<p>Unlike <code class="highlighter-rouge">username</code>, the properties <code class="highlighter-rouge">changeName</code> and <code class="highlighter-rouge">changeYearOfBirth</code> are methods. These properties point to the functions of the same name. Both functions reset the <code class="highlighter-rouge">name</code> and <code class="highlighter-rouge">yearOfBirth</code> properties of whatever object they are called from, respectively.</p>

<p>They also change the <code class="highlighter-rouge">username</code> property by invoking <code class="highlighter-rouge">updateUsername</code>, a function scoped to <code class="highlighter-rouge">createProfile</code>. <code class="highlighter-rouge">changeName</code> and <code class="highlighter-rouge">changeYearOfBirth</code> can invoke <code class="highlighter-rouge">updateUsername</code> even when the object they are called from is outside the scope of <code class="highlighter-rouge">createProfile</code> because these functions have closure over <code class="highlighter-rouge">createProfile</code>.</p>

<p><strong>Essentially this makes <code class="highlighter-rouge">updateUsername</code> a private function.</strong> It cannot be called directly outside of the context of <code class="highlighter-rouge">createProfile</code>, but it can continue to operate when <code class="highlighter-rouge">changeName</code> and <code class="highlighter-rouge">changeYearOfBirth</code> get called.</p>

<p>In this example <code class="highlighter-rouge">updateUsername</code> isn‚Äôt that interesting of a function. It seems kind of trivial that we would want to keep private a function that performs a pretty simple concatenation operation. But you can imagine scenarios where keeping functions private is anything but trivial.</p>

<p>What if instead of returning a small <code class="highlighter-rouge">profile</code> object, we had a function that returned a huge public API, with tons of methods and data? It‚Äôs a safe bet that some of the methods that get returned in our public API rely on helper functions or variables that we don‚Äôt want the public to be able to access directly. In order for the methods that were returned by the API to work outside the context of their creation, we need a way to allow them to slide back into their original scope and look up those private methods. This is precisely what closure affords.</p>

<p><em>**Note: for an extended discussion on the relation of closure to APIs and modules, see <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch5.md#modules">this</a> section in Kyle Simpson‚Äôs <a href="https://github.com/getify/You-Dont-Know-JS/tree/master/scope%20%26%20closures">You Don‚Äôt Know JS: Scope &amp; Closure</a></em></p>

<h2 id="wrapping-up">Wrapping up</h2>

<p>Hopefully by now you understand a little more about what closure is and why it‚Äôs important to JavaScript. It‚Äôs not the easiest concept to figure out, and I gather that fully appreciating it requires a somewhat sophisticated understanding of scope.</p>

<p>With that said, I hope you‚Äôll continue to research this topic by referencing some of the resources I mentioned earlier or others that you find online. As always seems to be the case with JavaScript, for every important programming topic to be learned, there are thousands great explanations floating around the web just waiting to be absorbed.</p>
:ET