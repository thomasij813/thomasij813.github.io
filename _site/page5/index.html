<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <link href="http://gmpg.org/xfn/11" rel="profile">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      Thomas Johnson
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/styles.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/icon.png">
  <link rel="shortcut icon" href="/public/icon-small.png">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="Thomas Johnson" href="/atom.xml">

  <!-- JS -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
  <script src="http://ajax.aspnetcdn.com/ajax/jquery.validate/1.14.0/jquery.validate.min.js"></script>
  <script src="/script.js"></script>
</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/" title="Home">Thomas Johnson</a>
        </h3>
        <ul>
          
            
              <li><a class="small" href="/about">About</a></li>
            
          
            
              <li><a class="small" href="/projects">Projects</a></li>
            
          
            
              <li><a class="small" href="/archive">Archive</a></li>
            
          
            
              <li><a class="small" href="/contact">Contact</a></li>
            
          
        </ul>
        <div class="below-header">
          <div class="hr"></div>
          <img src="https://farm6.staticflickr.com/5831/20836963561_b5d4186595_o_d.jpg" alt="" class="zebra_image">
          <div class="hr"></div>
        </div>
      </header>

      <main>
        <div class="posts">
  
  <article class="post">
    <h1 class="post-title">
      <a href="/2015/12/01/getting-closure/">
        Getting Closure
      </a>
    </h1>

    <time datetime="2015-12-01T00:00:00-08:00" class="post-date">01 Dec 2015</time>

    <p>I’ve spent the last couple years learning JavaScript, but I’m just now starting to get the hang of closure. It’s a tricky but important concept, one that trips up a lot of programmers new to JavaScript and sometimes even eludes experienced developers.</p>

<p>In this post, I’m going to try and explain the concept to the best of my abilities. This will by no means be a comprehensive explanation, and given my limited expertise I encourage readers to check out more authoritative sources before carrying whatever knowledge gained here into practice.</p>

<p>In particular, I highly recommend reading Kyle Simpson’s <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch5.md">chapter on closure</a> from his excellent <a href="https://github.com/getify/You-Dont-Know-JS">You Don’t Know JS</a> series and the relevant passages from Douglas Crockford’s classic, <a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742">JavaScript: The Good Parts</a>.</p>

<h2 id="lets-talk-about-scope">Let’s talk about scope</h2>

<p>Before getting to closure, it’s important to understand what scope is and how it works.</p>

<p><strong>Put simply, in JavaScript scope refers to the rules that the engine abides by when it performs variable lookups.</strong> As you probably know, successfully looking up variables depends a lot on the namespaces they were assigned to and the context from which they are being looked up.</p>

<p>Most developers know that trying to reference variables that were defined within a function from beyond the context of that function will return an error. This is because the variables were scoped to the namespace of the function they were defined in, and trying to call these variables from outside that namespace is forbidden by JavaScript’s engine.</p>

<p>Take a look at the following code snippet:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">I'm scoped to global!</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">I'm scoped to foo!</span><span class="dl">"</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">();</span> <span class="c1">// I'm scoped to global! I'm scoped to foo!</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// error</span></code></pre></figure>

<p>When we invoke <code class="language-plaintext highlighter-rouge">foo</code>, the engine steps inside the function to execute its code, so to speak. This means that while its executing <code class="language-plaintext highlighter-rouge">foo</code>, the engine has access to all the variables mapped to that function’s namespace. For these reasons, <code class="language-plaintext highlighter-rouge">foo</code> is able to log successfully both <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>.</p>

<p>We run into problems when we attempt to log <code class="language-plaintext highlighter-rouge">b</code> from outside of <code class="language-plaintext highlighter-rouge">foo</code>. While it may seem strange that that the engine raises an error when we try to call <code class="language-plaintext highlighter-rouge">b</code> just six lines after defining it, according to the rules of scope, <code class="language-plaintext highlighter-rouge">b</code> is mapped to <code class="language-plaintext highlighter-rouge">foo</code>’s namespace. Trying to access <code class="language-plaintext highlighter-rouge">b</code> from outside the context of <code class="language-plaintext highlighter-rouge">foo</code>’s namespace is just not possible.</p>

<p>That being understood, why then was <code class="language-plaintext highlighter-rouge">foo</code> able to call <code class="language-plaintext highlighter-rouge">a</code>? It seem’s like a contradiction to say that on one hand we are unable to look up <code class="language-plaintext highlighter-rouge">b</code> from outside <code class="language-plaintext highlighter-rouge">foo</code> because <code class="language-plaintext highlighter-rouge">foo</code> is where <code class="language-plaintext highlighter-rouge">b</code> was created, but on the other hand to say that <code class="language-plaintext highlighter-rouge">foo</code> can totally look up <code class="language-plaintext highlighter-rouge">a</code> even though <code class="language-plaintext highlighter-rouge">a</code> wasn’t defined there. Both lookups refer to variables that were defined somewhere other than the execution context of the call, so why does JavaScript forbid one lookup but not the other?</p>

<p>The answer has less to do with what kind of lookups are forbidden and allowed by the JavaScript engine, and more with how that actual lookup process is performed. <strong>At this point, I should come clean about something: when I say scope is all about rules, I’m being a little misleading. In truth, it’s more appropriate to think of scope in terms of a constrained route the engine takes when it’s tasked with looking up variables.</strong></p>

<p>When you reference a variable in your code, the JavaScript engine takes a strongly specified path to look it up. First, it looks to see if the variable was added to the current scope, that is, it checks to see if that variable exists within the namespace of the current execution context (ie, function). If it doesn’t find the variable in the current namespace, it take one step backward and checks to see if the namespace of the parent scope contains the requested variable. If again the engine fails to find the variable there, it checks the namespace of the parent’s parent scope, and so on all the way to the <code class="language-plaintext highlighter-rouge">global</code> scope.</p>

<p>The <code class="language-plaintext highlighter-rouge">global</code> scope happens to be the final namespace on the engine’s lookup path. It provides access to variables that were defined outside of any function or variables that were declared without the preceding keyword <code class="language-plaintext highlighter-rouge">var</code>. There is no parent scope to <code class="language-plaintext highlighter-rouge">global</code>, so if the engine reaches it all the way here without finding the variable it needs, it raises a reference error.</p>

<p>All functions and their namespaces, no matter how deeply nested, have access to the variables scoped to <code class="language-plaintext highlighter-rouge">global</code>. As a result, it can be very tempting to define all of the variables you’ll ever need in the namespace of the <code class="language-plaintext highlighter-rouge">global</code> scope. <strong>In truth, however, assigning variables to <code class="language-plaintext highlighter-rouge">global</code> is rarely a good idea, and it should be avoided.</strong></p>

<p>Now that we know a little more about scope, the answer to our question about why <code class="language-plaintext highlighter-rouge">foo</code> was able to reference <code class="language-plaintext highlighter-rouge">a</code> should be clear. Here’s the code snippet from earlier:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">I'm scoped to global!</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">I'm scoped to foo!</span><span class="dl">"</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">();</span> <span class="c1">// I'm scoped to global! I'm scoped to foo!</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// error</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">a</code> was defined within the <code class="language-plaintext highlighter-rouge">global</code> scope. When we invoke <code class="language-plaintext highlighter-rouge">foo</code>, the engine is tasked with finding <code class="language-plaintext highlighter-rouge">a</code>. When it fails to find it within <code class="language-plaintext highlighter-rouge">foo</code>’s namespace, the engine takes a step backward and finds it in <code class="language-plaintext highlighter-rouge">foo</code>’s parent, the <code class="language-plaintext highlighter-rouge">global</code> scope.</p>

<p>Knowing how variables are looked up by the engine is important, and it allows us to better appreciate what the engine is doing to find variables. Before moving on to closure, however, I think it would serve our purpose to examine one more code snippet:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">I'm scoped to foo!</span><span class="dl">"</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">I'm scoped to bar!</span><span class="dl">"</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">bar</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">baz</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">I'm scoped to baz!</span><span class="dl">"</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">();</span> <span class="c1">// I'm scoped to foo! I'm scoped to bar!</span>
<span class="nx">baz</span><span class="p">();</span> <span class="c1">// error</span></code></pre></figure>

<p>Before you continue reading, try and figure out why invoking <code class="language-plaintext highlighter-rouge">foo</code> succeeded and invoking <code class="language-plaintext highlighter-rouge">baz</code> failed. What path does the engine take to look up the variables these two functions reference?</p>

<p>As I mentioned earlier, it’s only somewhat correct to say that the reason invoking <code class="language-plaintext highlighter-rouge">baz</code> raises an error when it attempts to log <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> is because the rules of scope forbid the engine from breaking the current execution context (which happens to be the function <code class="language-plaintext highlighter-rouge">baz</code>) and accessing the namespaces of <code class="language-plaintext highlighter-rouge">foo</code> and <code class="language-plaintext highlighter-rouge">bar</code>, the functions where those variables are defined. It’s better to say that the reason has to do with the route the engine takes when it tries to find those variables, a route that <code class="language-plaintext highlighter-rouge">foo</code> and <code class="language-plaintext highlighter-rouge">bar</code> just aren’t on.</p>

<p>Following the variable lookup path helps reveal why <code class="language-plaintext highlighter-rouge">baz</code> came up short when it tried calling <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>. Tracing the lookup path taken by the engine when we invoke <code class="language-plaintext highlighter-rouge">foo</code> also explains why that function was able to successfully look up the same variables.</p>

<p>The final line of <code class="language-plaintext highlighter-rouge">foo</code> invokes <code class="language-plaintext highlighter-rouge">bar</code>, a function nested inside <code class="language-plaintext highlighter-rouge">foo</code> that logs the two variables. This means that invoking <code class="language-plaintext highlighter-rouge">foo</code> pushes our execution context to <code class="language-plaintext highlighter-rouge">bar</code>. Finding <code class="language-plaintext highlighter-rouge">b</code> from inside <code class="language-plaintext highlighter-rouge">bar</code> is easy for the JavaScript engine since that’s the function where <code class="language-plaintext highlighter-rouge">b</code> was declared. The process the engine takes to find <code class="language-plaintext highlighter-rouge">a</code>, however, is complicated by the fact that there is no variable named <code class="language-plaintext highlighter-rouge">a</code> in <code class="language-plaintext highlighter-rouge">bar</code>’s namespace. Upon finding this out, the engine consults the namespace of <code class="language-plaintext highlighter-rouge">bar</code>’s parent scope, <code class="language-plaintext highlighter-rouge">foo</code>, where there is a variable named <code class="language-plaintext highlighter-rouge">a</code>. Hence, both variables are successfully able to be looked up by the engine and logged to the console.</p>

<p>We started this discussion by thinking about scope in terms of rules of access the engine follows when it performs variable lookups. We ended it, however, by demonstrating a subtle but important reformulation: <strong>scope is the constraining mechanism that binds the engine to a specified path of nested namespaces in order to complete variable lookups.</strong> Starting with the scope of the current execution context, upon failing to find a variable the engine navigates backward consulting each parent scope until reaching the <code class="language-plaintext highlighter-rouge">global</code> scope, ultimately either finding the variable it needs and returning its value or not and raising a reference error.</p>

<h2 id="on-to-closure">On to closure…</h2>

<p>Let’s take a look at another code snippet:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">I'm scoped to bar!</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span>  <span class="p">{</span>
    <span class="na">bar</span><span class="p">:</span> <span class="nx">bar</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">bar</span><span class="p">();</span> <span class="c1">// error</span>

<span class="kd">var</span> <span class="nx">baz</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">();</span>
<span class="nx">baz</span><span class="p">.</span><span class="nx">bar</span><span class="p">();</span> <span class="c1">// I'm scoped to bar!</span></code></pre></figure>

<p>Here we’ve created a function that returns an object. The object contains only one property, a method named <code class="language-plaintext highlighter-rouge">bar</code> that happens to point to a function of the same name nested inside <code class="language-plaintext highlighter-rouge">foo</code>. Trying to call <code class="language-plaintext highlighter-rouge">bar()</code> from the execution context of the <code class="language-plaintext highlighter-rouge">global</code> scope results in an error.</p>

<p>So far, none of this is surprising. When we try to invoke <code class="language-plaintext highlighter-rouge">bar</code> from the <code class="language-plaintext highlighter-rouge">global</code> scope, we are essentially trying to call a function that cannot be accessed by the engine. <code class="language-plaintext highlighter-rouge">bar</code> is scoped to <code class="language-plaintext highlighter-rouge">foo</code>, so trying to call <code class="language-plaintext highlighter-rouge">bar</code> from the context of the <code class="language-plaintext highlighter-rouge">global</code> scope, which is the parent of <code class="language-plaintext highlighter-rouge">foo</code>, will fail. <strong>Remember, when the engine can’t find something in the namespace of the current execution context, it starts looking in the namespace of each parent scope.</strong> The <code class="language-plaintext highlighter-rouge">global</code> scope doesn’t have any parents, so when the engine fails to find <code class="language-plaintext highlighter-rouge">bar</code> in the <code class="language-plaintext highlighter-rouge">global</code> namespace, it’s forced to return an error.</p>

<p>Notice, however, that invoking <code class="language-plaintext highlighter-rouge">baz.bar</code> executes correctly. Given our knowledge of scope, this should raise an important question: why is it that calling a method from the <code class="language-plaintext highlighter-rouge">global</code> scope that happens to point to <code class="language-plaintext highlighter-rouge">bar</code> succeeds and just calling <code class="language-plaintext highlighter-rouge">bar</code> directly fails? Aren’t both of these invocations performing lookups on a function that is defined in a namespace that cannot be reached from <code class="language-plaintext highlighter-rouge">global</code>?</p>

<p><strong>The reason this works is because <code class="language-plaintext highlighter-rouge">baz.bar</code>, being a property on the object returned by <code class="language-plaintext highlighter-rouge">foo</code>, has closure over <code class="language-plaintext highlighter-rouge">foo</code>.</strong> The upshot of this is that when <code class="language-plaintext highlighter-rouge">baz.bar</code> gets invoked, the execution context slides momentarily back inside <code class="language-plaintext highlighter-rouge">bar</code>, meaning that <code class="language-plaintext highlighter-rouge">baz.bar</code> can call any variables that <code class="language-plaintext highlighter-rouge">bar</code> had access to as a function nested inside <code class="language-plaintext highlighter-rouge">foo</code>.</p>

<p>This might give you the impression that <code class="language-plaintext highlighter-rouge">baz.bar</code> is breaking the “rules” of scope by being able to reference variables that aren’t within the current execution context of <code class="language-plaintext highlighter-rouge">baz</code> (ie, the <code class="language-plaintext highlighter-rouge">global</code> scope). <strong>In truth, calling <code class="language-plaintext highlighter-rouge">baz.bar</code> shifts the execution context, so to speak, so no “rules” are being broken here, and lookups get performed just as would be expected.</strong></p>

<p>If you think this has something to do with the fact that <code class="language-plaintext highlighter-rouge">baz.bar</code> is a method on the object returned by <code class="language-plaintext highlighter-rouge">foo</code>, think again. The following code operates according to the same logic of closure:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>

  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">I've been scoped to foo!</span><span class="dl">"</span>

  <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">bar</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>  <span class="c1">// error</span>
<span class="nx">bar</span><span class="p">();</span>           <span class="c1">// error</span>

<span class="kd">var</span> <span class="nx">baz</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">();</span> <span class="c1">// returns a pointer to the function object bar and assigns it to baz</span>
<span class="nx">baz</span><span class="p">();</span>           <span class="c1">// I've been scoped to foo!</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">bar</code> are both scoped to <code class="language-plaintext highlighter-rouge">foo</code>’s namespace, so attempting to call them from the <code class="language-plaintext highlighter-rouge">global</code> scope results in an error. <code class="language-plaintext highlighter-rouge">baz</code>, on the other hand, is assigned to the result of invoking <code class="language-plaintext highlighter-rouge">foo</code>, meaning that <code class="language-plaintext highlighter-rouge">baz</code> points to <code class="language-plaintext highlighter-rouge">bar</code>. Just like in our earlier example when I said that <code class="language-plaintext highlighter-rouge">baz.bar</code> had closure over <code class="language-plaintext highlighter-rouge">foo</code>, here <code class="language-plaintext highlighter-rouge">bar</code> also has closure over <code class="language-plaintext highlighter-rouge">foo</code>. This means that invoking <code class="language-plaintext highlighter-rouge">baz</code> in turn invokes <code class="language-plaintext highlighter-rouge">bar</code>, and this, speaking a little crudely, <strong>is what slides the execution context back inside <code class="language-plaintext highlighter-rouge">bar</code>, a subtle maneuver affording the engine a variable lookup path on which it can locate <code class="language-plaintext highlighter-rouge">a</code>.</strong></p>

<p>In both these examples, <code class="language-plaintext highlighter-rouge">bar</code> has closure over <code class="language-plaintext highlighter-rouge">foo</code>, the function it was created in. And since <code class="language-plaintext highlighter-rouge">foo</code> returned <code class="language-plaintext highlighter-rouge">bar</code>—as either a method on an object or directly itself—in a certain fashion <code class="language-plaintext highlighter-rouge">bar</code> can continue to live on and function even outside <code class="language-plaintext highlighter-rouge">foo</code>’s scope.</p>

<h2 id="privacy">Privacy</h2>

<p>If you understand closure and it doesn’t seem surprising to you, congratulations, you must have an excellent understanding of scope. Being able to intuitively determine how context shifts as code gets executed and how variables are looked up according to the scoping mechanism are the prerequisites to understanding and employing closure. <strong>When these things become second nature, so too will the idea of closure.</strong></p>

<p>With that said, it’s worthwhile to dwell on the powerful functionality that closure affords. <strong>Because closure allows us to reference variables scoped to namespaces we otherwise could not access, it’s very easy to write code whose execution relies on private resources.</strong></p>

<p>Consider the following code snippet:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">createProfile</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">yearOfBirth</span><span class="p">)</span> <span class="p">{</span>

  <span class="kd">function</span> <span class="nx">updateUsername</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">yearOfBirth</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">name</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">yearOfBirth</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">changeName</span><span class="p">(</span><span class="nx">newName</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">newName</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">username</span> <span class="o">=</span> <span class="nx">updateUsername</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">yearOfBirth</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">changeYearOfBirth</span><span class="p">(</span><span class="nx">newYearOfBirth</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">yearOfBirth</span> <span class="o">=</span> <span class="nx">newYearOfBirth</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">username</span> <span class="o">=</span> <span class="nx">updateUsername</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">yearOfBirth</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">profile</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="nx">name</span><span class="p">,</span>
    <span class="na">yearOfBirth</span><span class="p">:</span> <span class="nx">yearOfBirth</span><span class="p">,</span>
    <span class="na">username</span><span class="p">:</span> <span class="nx">updateUsername</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">yearOfBirth</span><span class="p">),</span>
    <span class="na">changeName</span><span class="p">:</span> <span class="nx">changeName</span><span class="p">,</span>
    <span class="na">changeYearOfBirth</span><span class="p">:</span> <span class="nx">changeYearOfBirth</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="nx">profile</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">profile</span> <span class="o">=</span> <span class="nx">createProfile</span><span class="p">(</span><span class="dl">"</span><span class="s2">Franklin</span><span class="dl">"</span><span class="p">,</span> <span class="mi">1988</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">profile</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>        <span class="c1">// Franklin;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">profile</span><span class="p">.</span><span class="nx">yearOfBirth</span><span class="p">);</span> <span class="c1">// 1988</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">profile</span><span class="p">.</span><span class="nx">username</span><span class="p">);</span>    <span class="c1">// Frankl1988</span>

<span class="nx">profile</span><span class="p">.</span><span class="nx">username</span><span class="p">();</span>               <span class="c1">// error</span>

<span class="nx">profile</span><span class="p">.</span><span class="nx">changeName</span><span class="p">(</span><span class="dl">"</span><span class="s2">Montgomery</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">profile</span><span class="p">.</span><span class="nx">changeYearOfBirth</span><span class="p">(</span><span class="mi">1950</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">profile</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>        <span class="c1">// Montgomery</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">profile</span><span class="p">.</span><span class="nx">yearOfBirth</span><span class="p">);</span> <span class="c1">// 1950</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">profile</span><span class="p">.</span><span class="nx">username</span><span class="p">);</span>    <span class="c1">// Montgo1950</span></code></pre></figure>

<p>In this example, I have created a <code class="language-plaintext highlighter-rouge">createProfile</code> function that takes as arguments a name and a year of birth and returns a <code class="language-plaintext highlighter-rouge">profile</code> object. The <code class="language-plaintext highlighter-rouge">profile</code> object contains five properties, two of which are assigned to whatever name and year of birth that was originally passed to the <code class="language-plaintext highlighter-rouge">createProfile</code> function.</p>

<p>The property <code class="language-plaintext highlighter-rouge">username</code> is set to a string that is created as the result of passing <code class="language-plaintext highlighter-rouge">name</code> and <code class="language-plaintext highlighter-rouge">yearOfBirth</code> to the <code class="language-plaintext highlighter-rouge">updateUsername</code> function. <strong>Notice that <code class="language-plaintext highlighter-rouge">username</code> is not set to the function <code class="language-plaintext highlighter-rouge">updateUsername</code>; instead it’s set to the result of invoking <code class="language-plaintext highlighter-rouge">updateUsername</code>.</strong> If you tried to invoke <code class="language-plaintext highlighter-rouge">username</code> as a property of <code class="language-plaintext highlighter-rouge">profile</code> you would receive an error because <code class="language-plaintext highlighter-rouge">profile.username</code> is not a function. It’s just a string.</p>

<p>Unlike <code class="language-plaintext highlighter-rouge">username</code>, the properties <code class="language-plaintext highlighter-rouge">changeName</code> and <code class="language-plaintext highlighter-rouge">changeYearOfBirth</code> are methods. These properties point to the functions of the same name. Both functions reset the <code class="language-plaintext highlighter-rouge">name</code> and <code class="language-plaintext highlighter-rouge">yearOfBirth</code> properties of whatever object they are called from, respectively.</p>

<p>They also change the <code class="language-plaintext highlighter-rouge">username</code> property by invoking <code class="language-plaintext highlighter-rouge">updateUsername</code>, a function scoped to <code class="language-plaintext highlighter-rouge">createProfile</code>. <code class="language-plaintext highlighter-rouge">changeName</code> and <code class="language-plaintext highlighter-rouge">changeYearOfBirth</code> can invoke <code class="language-plaintext highlighter-rouge">updateUsername</code> even when the object they are called from is outside the scope of <code class="language-plaintext highlighter-rouge">createProfile</code> because these functions have closure over <code class="language-plaintext highlighter-rouge">createProfile</code>.</p>

<p><strong>Essentially this makes <code class="language-plaintext highlighter-rouge">updateUsername</code> a private function.</strong> It cannot be called directly outside of the context of <code class="language-plaintext highlighter-rouge">createProfile</code>, but it can continue to operate when <code class="language-plaintext highlighter-rouge">changeName</code> and <code class="language-plaintext highlighter-rouge">changeYearOfBirth</code> get called.</p>

<p>In this example <code class="language-plaintext highlighter-rouge">updateUsername</code> isn’t that interesting of a function. It seems kind of trivial that we would want to keep private a function that performs a pretty simple concatenation operation. But you can imagine scenarios where keeping functions private is anything but trivial.</p>

<p>What if instead of returning a small <code class="language-plaintext highlighter-rouge">profile</code> object, we had a function that returned a huge public API, with tons of methods and data? It’s a safe bet that some of the methods that get returned in our public API rely on helper functions or variables that we don’t want the public to be able to access directly. In order for the methods that were returned by the API to work outside the context of their creation, we need a way to allow them to slide back into their original scope and look up those private methods. This is precisely what closure affords.</p>

<p><em>**Note: for an extended discussion on the relation of closure to APIs and modules, see <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch5.md#modules">this</a> section in Kyle Simpson’s <a href="https://github.com/getify/You-Dont-Know-JS/tree/master/scope%20%26%20closures">You Don’t Know JS: Scope &amp; Closure</a></em></p>

<h2 id="wrapping-up">Wrapping up</h2>

<p>Hopefully by now you understand a little more about what closure is and why it’s important to JavaScript. It’s not the easiest concept to figure out, and I gather that fully appreciating it requires a somewhat sophisticated understanding of scope.</p>

<p>With that said, I hope you’ll continue to research this topic by referencing some of the resources I mentioned earlier or others that you find online. As always seems to be the case with JavaScript, for every important programming topic to be learned, there are thousands great explanations floating around the web just waiting to be absorbed.</p>

  </article>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page6">Previous Post</a>
  
  
    <a class="pagination-item newer" href="/page4">Next Post</a>
  
</div>

      </main>

      <footer class="footer">
        <small>
          &copy; <time datetime="2019-12-13T11:17:03-08:00">2019</time>. All rights reserved.
        </small>
      </footer>
    </div>
  </body>
</html>
